<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Testing and Estimation in One and Two-Samples</title>
    <meta charset="utf-8" />
    <meta name="author" content="Robert W. Walker" />
    <meta name="date" content="2020-04-20" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/jquery/jquery.min.js"></script>
    <link href="libs/leaflet/leaflet.css" rel="stylesheet" />
    <script src="libs/leaflet/leaflet.js"></script>
    <link href="libs/leafletfix/leafletfix.css" rel="stylesheet" />
    <script src="libs/Proj4Leaflet/proj4-compressed.js"></script>
    <script src="libs/Proj4Leaflet/proj4leaflet.js"></script>
    <link href="libs/rstudio_leaflet/rstudio_leaflet.css" rel="stylesheet" />
    <script src="libs/leaflet-binding/leaflet.js"></script>
    <link href="libs/datatables-css/datatables-crosstalk.css" rel="stylesheet" />
    <script src="libs/datatables-binding/datatables.js"></script>
    <link href="libs/dt-core/css/jquery.dataTables.min.css" rel="stylesheet" />
    <link href="libs/dt-core/css/jquery.dataTables.extra.css" rel="stylesheet" />
    <script src="libs/dt-core/js/jquery.dataTables.min.js"></script>
    <link href="libs/crosstalk/css/crosstalk.css" rel="stylesheet" />
    <script src="libs/crosstalk/js/crosstalk.min.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Testing and Estimation in One and Two-Samples
## Discrimination and Concrete
### Robert W. Walker
### 2020-04-20

---


# How do we learn from data?


--

.right[![](https://media.giphy.com/media/Jp3tixBJ0YERe4PXig/giphy.gif)]

--

It is probably better posed as, what can we learn from data?






---

# The Big Idea

Inference.

In the most basic form, learning something about data that we do not have from data that we do.  In the jargon of statistics, we characterize the probability distribution of some feature of the population of interest from a sample drawn randomly from that population.  

**Describe some key feature with appropriate uncertainty derived from a sample of data.**

---
# Inference for Data

Of two forms:

1. Binary/Qualitative

--

2. Quantitative

---
# Qualitative: The Binomial

Is entirely defined by two parameters, `\(n\)` -- the number of subjects -- and `\(\pi\)` -- the probability of a positive response.  The probability of exactly `\(x\)` positive responses is given by:

$$ Pr(X = x | \pi, n) = {n \choose x} \pi^x (1-\pi)^{n-x} $$

The binomial is the `canonical` distribution for binary outcomes.  Assuming all `\(n\)` subjects are alike and the outcome occurs with `\(\pi\)` probability, then we must have a sample from a binomial.  Now let's grab some data and frame a question.

---

## Berkeley Admissions

What is the probability of being admitted to Berkeley?&lt;sup&gt;1&lt;/sup&gt;

--


```r
UCBTab &lt;- data.frame(UCBAdmissions) %&gt;% reshape::untable(., .$Freq) %&gt;% select(-Freq)
table(UCBTab$Admit)
```

```
## 
## Admitted Rejected 
##     1755     2771
```

1755 of 4526 were admitted.  Now let's calculate the probability of admission just based on the data.  This proportion will later appear as `\(\hat{p}\)`.

--


```r
prop.table(table(UCBTab$Admit))
```

```
## 
##  Admitted  Rejected 
## 0.3877596 0.6122404
```


.footnote[&lt;sup&gt;1&lt;/sup&gt; **We probably think this depends on a bunch of applicant specific features but we will put that to the side for now.**]

---
class: inverse

## A Visual


```r
ggplot(UCBTab) +
 aes(x = Gender, fill = Admit) +
 geom_bar() +
 scale_fill_hue() +
 theme_minimal()
```

![](index_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;


---

# The Idea

Suppose we want to know `\(\pi(Admit)\)` -- the probability of being admitted -- with 90% probability.  We want to take the data that we saw and use it to **infer** the likely values of `\(\pi(Admit)\)`.  

---

One way to do it might be this.  

**Suppose I have 4526 chips with 1755 green and 2771 red.  I toss them all on the floor**

--

and pick them up, one at a time, 

--

record the value [green/red], 

--

put the chip back, and repeat 4526 times.  

--

I put it back or I would also get exactly the same `sample`.  Each sample of 4526 chips constitutes an estimate of the probability of Admit.

--

I wrote a little program to do just this -- `ResampleProps`.  

```
remotes::install_github("robertwwalker/ResampleProps")
```
---

# The Result


```r
library(ResampleProps)
RSMP &lt;- ResampleProp(UCBTab$Admit, k = 10000, tab.col = 1) %&gt;% data.frame(Pi.Admit=., Gender=as.character("All")) 
quantile(RSMP$Pi.Admit, probs = c(0.05,0.95))
```

```
##        5%       95% 
## 0.3758285 0.3996907
```

What is our estimate of `\(\pi\)` with 90% confidence?  The probability of admission ranges from 0.3758285 to 0.3996907.

---

# A Plot


```r
library(ggthemes)
RSMP %&gt;%  ggplot(., aes(x=Pi.Admit)) + geom_density(outline.type = "upper", color="blue") +labs(x=expression(pi)) + theme_minimal() + theme_xaringan()
```

![](index_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;


---
class: inverse

## There are three interchangeable methods

1. Resampling/Simulation
--
2. Exact binomial computation
--
3. A normal approximation

---

## Another Way: Exact binomial

That last procedure is correct but it is overkill.

With probability of 0.95, how small could `\(\pi\)` be to have gotten 1755 of 4526 or more?  With probability 0.05, how big could `\(\pi\)` to have gotten 1755 of 4526 or fewer?


```r
binom.test(table(UCBTab$Admit), conf.level=0.9)
```

```
## 
## 	Exact binomial test
## 
## data:  table(UCBTab$Admit)
## number of successes = 1755, number of trials = 4526, p-value &lt; 2.2e-16
## alternative hypothesis: true probability of success is not equal to 0.5
## 90 percent confidence interval:
##  0.3757924 0.3998340
## sample estimates:
## probability of success 
##              0.3877596
```


---

## Verifying the Result


```r
table(UCBTab$Admit)
```

```
## 
## Admitted Rejected 
##     1755     2771
```

```r
pbinom(1755, 1755+2771, 0.3998340)
```

```
## [1] 0.05000037
```

```r
pbinom(1754, 1755+2771, 0.3757924)
```

```
## [1] 0.95
```

---

## binom.test()


```r
binom.test(1755, 1755+2771, conf.level=0.9)
```

```
## 
## 	Exact binomial test
## 
## data:  1755 and 1755 + 2771
## number of successes = 1755, number of trials = 4526, p-value &lt; 2.2e-16
## alternative hypothesis: true probability of success is not equal to 0.5
## 90 percent confidence interval:
##  0.3757924 0.3998340
## sample estimates:
## probability of success 
##              0.3877596
```

```r
Plot.Me &lt;- binom.test(1755, 1755+2771, conf.level=0.9)$conf.int %&gt;% data.frame()
```

With 90% probability, now often referred to as 90% confidence to avoid using the word probability twice, the probability of being admitted ranges between 0.3758 and 0.3998.  Let me show this.

---


```r
Binomial.Search &lt;- data.frame(x=seq(0.33,0.43, by=0.001)) %&gt;% mutate(Too.Low = pbinom(1755, 1755+2771, x), Too.High = 1-pbinom(1754, 1755+2771, x))
Binomial.Search %&gt;% pivot_longer(cols=c(Too.Low,Too.High)) %&gt;% ggplot(., aes(x=x, y=value, color=name)) + geom_line() + geom_hline(aes(yintercept=0.05)) + geom_hline(aes(yintercept=0.95))  + geom_vline(data=Plot.Me, aes(xintercept=.), linetype=3) + labs(title="Using the Binomial to Search", color="Greater/Lesser", x=expression(pi), y="Probability") + theme_xaringan() + scale_xaringan_color_discrete()
```

![](index_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---
## A Third Way: The normal approximation

As long as `\(n\)` and `\(\pi\)` are sufficiently large, we can approximate this with a normal distribution.  **This was also prove handy for a related reason.**  As long as `\(n*\pi\)` &gt; 10, we can write that a standard normal `\(z\)` describes the distribution of `\(\pi\)`, given `\(n\)` -- the sample size and `\(\hat{p}\)` -- the proportion of yes's/true's in the sample.

$$
Pr(\pi) = \hat{p} \pm z*\left(\sqrt{\frac{\hat{p}*(1-\hat{p})}{n}}\right)
$$

`\(R\)` implements this in `prop.test`.

---
class: inverse

# The normal approximation estimates


```r
prop.test(table(UCBTab$Admit), conf.level = 0.9)
```

```
## 
## 	1-sample proportions test with continuity correction
## 
## data:  table(UCBTab$Admit), null probability 0.5
## X-squared = 227.62, df = 1, p-value &lt; 2.2e-16
## alternative hypothesis: true p is not equal to 0.5
## 90 percent confidence interval:
##  0.3758075 0.3998471
## sample estimates:
##         p 
## 0.3877596
```

`\(R\)` reports the result as `\(z^2\)` not `\(z\)` which is `\(\chi^2\)` not normal.  This approximation yields an estimate of `\(\pi\)`, with 90% confidence, that ranges between 0.37 and 0.48.

---

# Give It a Rough Try for Men


```r
library(janitor); UCBTab %&gt;% tabyl(Gender,Admit) %&gt;% adorn_totals("col")
```

```
##  Gender Admitted Rejected Total
##    Male     1198     1493  2691
##  Female      557     1278  1835
```

--

The probability of being admitted, conditional on being Male, ranges from 0.43 to 0.46 with 90% confidence.


```r
binom.test(1198,2691, conf.level = 0.9)
```

```
## 
## 	Exact binomial test
## 
## data:  1198 and 2691
## number of successes = 1198, number of trials = 2691, p-value = 0.00000001403
## alternative hypothesis: true probability of success is not equal to 0.5
## 90 percent confidence interval:
##  0.4292930 0.4611706
## sample estimates:
## probability of success 
##              0.4451877
```

---

## The Thought Experiment


```r
UCBTM &lt;- UCBTab %&gt;% filter(Gender=="Male")
UCBTM.Pi &lt;- ResampleProp(UCBTM$Admit, k = 10000) %&gt;%  data.frame(Pi.Admit=., Gender = as.character("Male")) 
UCBTM.Pi %&gt;%  ggplot(., aes(x=Pi.Admit)) + geom_density(color="blue") + 
  labs(x=expression(pi)) + theme_clean()
```

![](index_files/figure-html/unnamed-chunk-13-1.png)&lt;!-- --&gt;


---

## Women


```r
UCBTab %&gt;% tabyl(Gender,Admit) %&gt;% adorn_totals("col")
```

```
##  Gender Admitted Rejected Total
##    Male     1198     1493  2691
##  Female      557     1278  1835
```

```r
UCBTF &lt;- UCBTab %&gt;% filter(Gender=="Female")
UCBTF.Pi &lt;- ResampleProp(UCBTF$Admit, k = 10000) %&gt;%  data.frame(Pi.Admit=., Gender=as.character("Female")) 
```

--


```r
binom.test(557,1835, conf.level = 0.9)
```

```
## 
## 	Exact binomial test
## 
## data:  557 and 1835
## number of successes = 557, number of trials = 1835, p-value &lt; 2.2e-16
## alternative hypothesis: true probability of success is not equal to 0.5
## 90 percent confidence interval:
##  0.2858562 0.3216944
## sample estimates:
## probability of success 
##              0.3035422
```

The probability of being of Admitted, given a Woman, ranges from 0.286 to 0.322 with 90% confidence.


---

# Succinctly

Female: from 0.286 to 0.322  
Male: from 0.43 to 0.46
All: from 0.3758 to 0.3998

![](index_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;

---
class: inverse


```r
UCB.Pi &lt;- bind_rows(UCBTF.Pi, UCBTM.Pi)
UCB.Pi %&gt;% ggplot(., aes(x=Gender, y=Pi.Admit, fill=Gender)) + geom_violin() + geom_label(aes(x=1.5, y=0.375), label="Too small to be male \n Too large to be female?", size=10, fill="black", color="white", inherit.aes = FALSE) + guides(size=FALSE)
```

![](index_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---
class: inverse


```r
library(patchwork)
UCB.Pi &lt;- bind_rows(UCBTF.Pi, UCBTM.Pi, RSMP)
UCB.Pi %&gt;% ggplot(., aes(x=Pi.Admit, fill=Gender)) + geom_density(alpha=0.2) +  ggplot(UCBTab) +
 aes(x = Gender, fill = Admit) +
 geom_bar() +
 scale_fill_hue() +
 theme_minimal()
```

![](index_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

---
background-image: url(https://github.com/yihui/xaringan/releases/download/v0.0.2/karl-moustache.jpg)
background-position: 50% 50%
class: center, bottom, inverse

# You only live once!

---

# Hello Ninja

As a presentation ninja, you certainly should not be satisfied by the "Hello World" example. You need to understand more about two:

1. The [remark.js](https://remarkjs.com) library;

1. The **xaringan** package;

Basically **xaringan** injected the chakra of R Markdown (minus Pandoc) into **remark.js**. The slides are rendered by remark.js in the web browser, and the Markdown source needed by remark.js is generated from R Markdown (**knitr**).

---

# remark.js

You can see an introduction of remark.js from [its homepage](https://remarkjs.com). You should read the [remark.js Wiki](https://github.com/gnab/remark/wiki) at least once to know how to

- create a new slide (Markdown syntax&lt;sup&gt;*&lt;/sup&gt; and slide properties);

- format a slide (e.g. text alignment);

- configure the slideshow;

- and use the presentation (keyboard shortcuts).

It is important to be familiar with remark.js before you can understand the options in **xaringan**.

.footnote[[*] It is different with Pandoc's Markdown! It is limited but should be enough for presentation purposes. Come on... You do not need a slide for the Table of Contents! Well, the Markdown support in remark.js [may be improved](https://github.com/gnab/remark/issues/142) in the future.]

---
background-image: url(https://github.com/yihui/xaringan/releases/download/v0.0.2/karl-moustache.jpg)
background-size: cover
class: center, bottom, inverse

# I was so happy to have discovered remark.js!

---
class: inverse, middle, center

# Using xaringan

---

# xaringan

Provides an R Markdown output format `xaringan::moon_reader` as a wrapper for remark.js, and you can use it in the YAML metadata, e.g.

```yaml
---
title: "A Cool Presentation"
output:
  xaringan::moon_reader
    yolo: true
    nature:
      autoplay: 30000
---
```

See the help page `?xaringan::moon_reader` for all possible options that you can use.

---

# remark.js vs xaringan

Some differences between using remark.js (left) and using **xaringan** (right):

.pull-left[
1. Start with a boilerplate HTML file;

1. Plain Markdown;

1. Write JavaScript to autoplay slides;

1. Manually configure MathJax;

1. Highlight code with `*`;

1. Edit Markdown source and refresh browser to see updated slides;
]

.pull-right[
1. Start with an R Markdown document;

1. R Markdown (can embed R/other code chunks);

1. Provide an option `autoplay`;

1. MathJax just works;&lt;sup&gt;*&lt;/sup&gt;

1. Highlight code with `{{}}`;

1. The RStudio addin "Infinite Moon Reader" automatically refreshes slides on changes;
]

.footnote[[*] Not really. See next page.]

---

# Math Expressions

You can write LaTeX math expressions inside a pair of dollar signs, e.g. &amp;#36;\alpha+\beta$ renders `\(\alpha+\beta\)`. You can use the display style with double dollar signs:

```
$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$
```

`$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$`

Limitations:

1. The source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting `$$` must appear in the very beginning of a line, followed immediately by a non-space character, and the ending `$$` must be at the end of a line, led by a non-space character;

1. There should not be spaces after the opening `$` or before the closing `$`.

1. Math does not work on the title slide (see [#61](https://github.com/yihui/xaringan/issues/61) for a workaround).

---

# R Code


```r
# a boring regression
fit = lm(dist ~ 1 + speed, data = cars)
coef(summary(fit))
```

```
#               Estimate Std. Error   t value             Pr(&gt;|t|)
# (Intercept) -17.579095  6.7584402 -2.601058 0.012318816153809031
# speed         3.932409  0.4155128  9.463990 0.000000000001489836
```

```r
dojutsu = c('地爆天星', '天照', '加具土命', '神威', '須佐能乎', '無限月読')
grep('天', dojutsu, value = TRUE)
```

```
# [1] "地爆天星" "天照"
```

---

# R Plots


```r
par(mar = c(4, 4, 1, .1))
plot(cars, pch = 19, col = 'darkgray', las = 1)
abline(fit, lwd = 2)
```

![](index_files/figure-html/cars-1.svg)&lt;!-- --&gt;

---

# Tables

If you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,


```r
knitr::kable(head(iris), format = 'html')
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; Sepal.Length &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Sepal.Width &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Petal.Length &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Petal.Width &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Species &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 5.1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; setosa &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 4.9 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; setosa &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 4.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.2 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1.3 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; setosa &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 4.6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1.5 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; setosa &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 5.0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.6 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; setosa &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 5.4 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.9 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1.7 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; setosa &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---

# HTML Widgets

I have not thoroughly tested HTML widgets against **xaringan**. Some may work well, and some may not. It is a little tricky.

Similarly, the Shiny mode (`runtime: shiny`) does not work. I might get these issues fixed in the future, but these are not of high priority to me. I never turn my presentation into a Shiny app. When I need to demonstrate more complicated examples, I just launch them separately. It is convenient to share slides with other people when they are plain HTML/JS applications.

See the next page for two HTML widgets.

---


```r
library(leaflet)
leaflet() %&gt;% addTiles() %&gt;% setView(-93.65, 42.0285, zoom = 17)
```

<div id="htmlwidget-a5602b321a7df609a3d5" style="width:100%;height:432px;" class="leaflet html-widget"></div>
<script type="application/json" data-for="htmlwidget-a5602b321a7df609a3d5">{"x":{"options":{"crs":{"crsClass":"L.CRS.EPSG3857","code":null,"proj4def":null,"projectedBounds":null,"options":{}}},"calls":[{"method":"addTiles","args":["//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",null,null,{"minZoom":0,"maxZoom":18,"tileSize":256,"subdomains":"abc","errorTileUrl":"","tms":false,"noWrap":false,"zoomOffset":0,"zoomReverse":false,"opacity":1,"zIndex":1,"detectRetina":false,"attribution":"&copy; <a href=\"http://openstreetmap.org\">OpenStreetMap<\/a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA<\/a>"}]}],"setView":[[42.0285,-93.65],17,[]]},"evals":[],"jsHooks":[]}</script>

---


```r
DT::datatable(
  head(iris, 10),
  fillContainer = FALSE, options = list(pageLength = 8)
)
```

<div id="htmlwidget-33116698679548612280" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-33116698679548612280">{"x":{"filter":"none","fillContainer":false,"data":[["1","2","3","4","5","6","7","8","9","10"],[5.1,4.9,4.7,4.6,5,5.4,4.6,5,4.4,4.9],[3.5,3,3.2,3.1,3.6,3.9,3.4,3.4,2.9,3.1],[1.4,1.4,1.3,1.5,1.4,1.7,1.4,1.5,1.4,1.5],[0.2,0.2,0.2,0.2,0.2,0.4,0.3,0.2,0.2,0.1],["setosa","setosa","setosa","setosa","setosa","setosa","setosa","setosa","setosa","setosa"]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Sepal.Length<\/th>\n      <th>Sepal.Width<\/th>\n      <th>Petal.Length<\/th>\n      <th>Petal.Width<\/th>\n      <th>Species<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":8,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[8,10,25,50,100]}},"evals":[],"jsHooks":[]}</script>

---

# Some Tips

- When you use the "Infinite Moon Reader" addin in RStudio, your R session will be blocked by default. You can click the red button on the right of the console to stop serving the slides, or use the _daemonized_ mode so that it does not block your R session. To do the latter, you can set the option

    ```r
    options(servr.daemon = TRUE)
    ```
    
    in your current R session, or in `~/.Rprofile` so that it is applied to all future R sessions. I do the latter by myself.
    
    To know more about the web server, see the [**servr**](https://github.com/yihui/servr) package.

--

- Do not forget to try the `yolo` option of `xaringan::moon_reader`.

    ```yaml
    output:
      xaringan::moon_reader:
        yolo: true
    ```

---

# Some Tips

- Slides can be automatically played if you set the `autoplay` option under `nature`, e.g. go to the next slide every 30 seconds in a lightning talk:

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          autoplay: 30000
    ```

--

- A countdown timer can be added to every page of the slides using the `countdown` option under `nature`, e.g. if you want to spend one minute on every page when you give the talk, you can set:

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          countdown: 60000
    ```

    Then you will see a timer counting down from `01:00`, to `00:59`, `00:58`, ... When the time is out, the timer will continue but the time turns red.

---

# Some Tips

- There are several ways to build incremental slides. See [this presentation](https://slides.yihui.name/xaringan/incremental.html) for examples.

- The option `highlightLines: true` of `nature` will highlight code lines that start with `*`, or are wrapped in `{{ }}`, or have trailing comments `#&lt;&lt;`;

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          highlightLines: true
    ```

    See examples on the next page.

---

# Some Tips


.pull-left[
An example using a leading `*`:

    ```r
    if (TRUE) {
    ** message("Very important!")
    }
    ```
Output:
```r
if (TRUE) {
* message("Very important!")
}
```

This is invalid R code, so it is a plain fenced code block that is not executed.
]

.pull-right[
An example using `{{}}`:

    ```{r tidy=FALSE}
    if (TRUE) {
    *{{ message("Very important!") }}
    }
    ```
Output:

```r
if (TRUE) {
* message("Very important!") 
}
```

It is valid R code so you can run it. Note that `{{}}` can wrap an R expression of multiple lines.
]

---

# Some Tips

An example of using the trailing comment `#&lt;&lt;` to highlight lines:

````markdown
```{r tidy=FALSE}
library(ggplot2)
ggplot(mtcars) + 
  aes(mpg, disp) + 
  geom_point() +   #&lt;&lt;
  geom_smooth()    #&lt;&lt;
```
````

Output:


```r
library(ggplot2)
ggplot(mtcars) + 
  aes(mpg, disp) + 
* geom_point() +
* geom_smooth()
```

---

# Some Tips

- To make slides work offline, you need to download a copy of remark.js in advance, because **xaringan** uses the online version by default (see the help page `?xaringan::moon_reader`).

- You can use `xaringan::summon_remark()` to download the latest or a specified version of remark.js. By default, it is downloaded to `libs/remark-latest.min.js`.

- Then change the `chakra` option in YAML to point to this file, e.g.

    ```yaml
    output:
      xaringan::moon_reader:
        chakra: libs/remark-latest.min.js
    ```

- If you used Google fonts in slides (the default theme uses _Yanone Kaffeesatz_, _Droid Serif_, and _Source Code Pro_), they won't work offline unless you download or install them locally. The Heroku app [google-webfonts-helper](https://google-webfonts-helper.herokuapp.com/fonts) can help you download fonts and generate the necessary CSS.

---

# Macros

- remark.js [allows users to define custom macros](https://github.com/yihui/xaringan/issues/80) (JS functions) that can be applied to Markdown text using the syntax `![:macroName arg1, arg2, ...]` or `![:macroName arg1, arg2, ...](this)`. For example, before remark.js initializes the slides, you can define a macro named `scale`:

    ```js
    remark.macros.scale = function (percentage) {
      var url = this;
      return '&lt;img src="' + url + '" style="width: ' + percentage + '" /&gt;';
    };
    ```

    Then the Markdown text

    ```markdown
    ![:scale 50%](image.jpg)
    ```

    will be translated to
    
    ```html
    &lt;img src="image.jpg" style="width: 50%" /&gt;
    ```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
