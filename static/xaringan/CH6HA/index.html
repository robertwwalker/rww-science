<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Time Series: A Forecasting Toolbox</title>
    <meta charset="utf-8" />
    <meta name="author" content="Robert W. Walker" />
    <meta name="date" content="2021-02-22" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Time Series: A Forecasting Toolbox
## FPP3, Chapter 5
### Robert W. Walker
### AGSM
### 2021-02-22

---






# Colleen's Question

---

# An Overview

---

## Packages

Getting started

```
library(tidyverse)
library(fpp3)
library(purrr)
library(gganimate)
library(seasonal)
library(tidyquant)
library(magrittr)
```
---

# The magic of `forecast`

The method:
1. Tidy  
2. Visualise  
3. Model  
  a. Specify  
  b. Estimate  
  c. Evaluate  
  d. Visualize  
4. Forecast

---
# Four Simple Methods

1. Average  
2. Naive method [Last value]  
3. Naive Seasonal Method  [Last seasonal values]
4. Drift method [Constant rate of change]  

---
# Fits and leftovers

Just as we can decompose a regression into explained and unexplained, we can decompose a time series regression into predicted or fitted and residual variation.

In a regression setting, we might have something like:

`$$y = \alpha + \beta x + \epsilon$$`
where x and y are observed data, `\(\alpha\)` is an intercept to be estimated, `\(\beta\)` is a slope to be estimated and `\(\epsilon\)` represents the residual.  Rearranging, the fitted/predicted value is 
`$$\hat{y} = \hat{\alpha} + x \hat{\beta}$$`
and the residual is: 

`$$\hat{e} = y - \hat{y}$$` or expanding and distributing:
`$$\hat{e} = y - \hat{\alpha} - x \hat{\beta}$$`
---
# Diagnostics for residuals

Seek to falsify two desirable characteristics:

1. Residuals should be uncorrelated [remaining time series information] 
2. Residuals should have mean zero [otherwise bias -- systematically wrong].

Additional desiderata include: Constant variance and normalcy though the latter implies the former.

`fable` makes this relatively straightforward with `augment` applied to a `tsibble`.  `tidy` renders details.

---
# Take Ford


```r
Ford &lt;- tq_get("F", from="2018-01-01") %&gt;% 
  as_tsibble(index=date) 
Ford %&gt;% autoplot(close)
```

&lt;img src="index_files/figure-html/unnamed-chunk-5-1.png" width="576" /&gt;

---
# That's Complete, but has missings


```r
Clean.Ford &lt;- Ford %&gt;%
  mutate(day = row_number()) %&gt;%
  update_tsibble(index = day, regular = TRUE)
F.Ford &lt;- Clean.Ford %&gt;% filter(date &lt; "2021-02-01")
autoplot(F.Ford, close) +
  labs(x = "Day", y = "Closing Price (US$)",
       title = "Ford since 2018")
```

&lt;img src="index_files/figure-html/unnamed-chunk-6-1.png" width="576" /&gt;

---
# Visualizing the Forecast Trajectory

`level` in the `autolayer` or `autoplot` containing the forecasts eliminates intervals.

```r
F.Res &lt;- F.Ford %&gt;%
  model(`Naive` = NAIVE(close), 
        `RW` = RW(close ~ drift()),
        `AVG` = MEAN(close)) %&gt;%
  forecast(h = 30)
autoplot(Clean.Ford, close) + autolayer(F.Res, level = NULL, size=1.25) + guides(level=FALSE) + hrbrthemes::theme_ipsum_rc() + labs(x="Trading Day since 1/1/2018", y="Closing Price", title="Comparing Simple Forecast Trajectories")
```

&lt;img src="index_files/figure-html/unnamed-chunk-7-1.png" width="576" /&gt;


---
# A Naive Forecast: Fitted values


```r
augmented &lt;- F.Ford %&gt;% model(NAIVE(close)) %&gt;% augment()
augmented %&gt;% filter(day &gt; 700) %&gt;% ggplot() + aes(x=day, y=close) + geom_line() + geom_line(aes(y=.fitted), color="red")
```

&lt;img src="index_files/figure-html/unnamed-chunk-8-1.png" width="576" /&gt;

---
# Residual Plot



```r
autoplot(augmented, .innov) +
  labs(x = "Day", y = "Residual",
       title = "Residuals from naïve method")
```

&lt;img src="index_files/figure-html/unnamed-chunk-9-1.png" width="576" /&gt;

---
# Over time correlations?

This looks pretty good....


```r
augmented %&gt;% ACF(.innov) %&gt;% autoplot()
```

&lt;img src="index_files/figure-html/unnamed-chunk-10-1.png" width="576" /&gt;

---
# The automagic plot


```r
F.Ford %&gt;% model(NAIVE(close)) %&gt;% gg_tsresiduals()
```

&lt;img src="index_files/figure-html/unnamed-chunk-11-1.png" width="576" /&gt;

---
# A Statistic

Could be white noise [the null hypothesis].....


```r
augmented %&gt;% features(.innov, ljung_box, lag = 10, dof = 0)
```

```
## # A tibble: 1 x 3
##   .model       lb_stat lb_pvalue
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;
## 1 NAIVE(close)    8.97     0.535
```
---
# A Random Walk

There's no drift....


```r
fit &lt;- F.Ford %&gt;% model(RW(close ~ drift()))
tidy(fit)
```

```
## # A tibble: 1 x 6
##   .model              term  estimate std.error statistic p.value
##   &lt;chr&gt;               &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 RW(close ~ drift()) b     -0.00275   0.00685    -0.402   0.688
```

---
# Assessment


```r
F.F2 &lt;- F.Ford %&gt;% model(RW(close ~ drift())) %&gt;% augment()
F.F2 %&gt;% ggplot() + aes(x=day, y=close) + geom_line() + geom_line(aes(y=.fitted), color="red") + geom_line(data=augmented, aes(y=.fitted), color="blue")
```

&lt;img src="index_files/figure-html/unnamed-chunk-14-1.png" width="576" /&gt;

---
## Intervals and Predictions

Two forms: 
1. Parametric: Assume a distribution for `\(e\)`.
2. Simulation: the bootstrap [using residuals]

---
# Parametric

Note the tiny negative drift....


```r
F.Res &lt;- F.Ford %&gt;%
  model(`Naive` = NAIVE(close), 
        `RW` = RW(close ~ drift()),
        `AVG` = MEAN(close)) %&gt;%
  forecast(h = 30)
autoplot(Clean.Ford, close) + autolayer(F.Res, level = NULL) + guides(level=FALSE)
```

&lt;img src="index_files/figure-html/unnamed-chunk-15-1.png" width="576" /&gt;

---
# Bootstrap


```r
F.Ford %&gt;%
  model(`Naive` = NAIVE(close), 
        `RW` = RW(close ~ drift())) %&gt;%
  forecast(h = 30, times=5, bootstrap=TRUE) %&gt;% autoplot() + guides(level=FALSE)
```

&lt;img src="index_files/figure-html/unnamed-chunk-16-1.png" width="576" /&gt;

---
# More Resamples make them smoother


```r
F.Ford %&gt;%
  model(`Naive` = NAIVE(close), 
        `RW` = RW(close ~ drift())) %&gt;%
  forecast(h = 30, times=500, bootstrap=TRUE) %&gt;% autoplot() + guides(level=FALSE)
```

&lt;img src="index_files/figure-html/unnamed-chunk-17-1.png" width="576" /&gt;

# Transformations and Forecasts

Are handled automagically by `fable` as long as they are a part of the workflow in the beginning of the chapter.


```r
FF3 &lt;- F.Ford %&gt;%
  model(`Naive` = NAIVE(log(close)), 
        `RW` = RW(log(close) ~ drift())) %&gt;%
  forecast(h = 30)
Clean.Ford %&gt;% filter(day &gt; 700) %&gt;% autoplot(close) + autolayer(FF3, level=NULL) + guides(level=FALSE)
```

&lt;img src="index_files/figure-html/unnamed-chunk-18-1.png" width="576" /&gt;

---
# Training and Test

Creating benchmarks for a forecast by slicing the extant data.

---
# Evaluating Forecasts

Three methods:
1. Points  
2. Distributions  
3. Cross-Validation  

---
# The Metrics

1. Mean Absolute Error [MAE]  
2. Root Mean Square Error [RMSE]
3. Mean Absolute Percentage Error [MAPE]  
4. symmetric Mean Absolute Percentage Error [sMAPE]  
5. Mean Absolute Scaled Error [MASE]
6. Root Mean Squared Scaled Error [RMSSE]

---
# Points


```r
Ford.Feb &lt;- Clean.Ford %&gt;% filter(date &gt;= "2020-02-01") %&gt;% as_tsibble(index=day)
ford_fit &lt;- F.Ford %&gt;%
  model(
    Mean = MEAN(close),
    `Naïve` = NAIVE(close),
    Drift = RW(close ~ drift())
  )
Ford.Forecast &lt;- ford_fit %&gt;% forecast(h=10)
```

---
# Assessment of Points


```r
Ford.Forecast %&gt;% accuracy(Clean.Ford)
```

```
## # A tibble: 3 x 10
##   .model .type    ME  RMSE   MAE   MPE  MAPE  MASE RMSSE  ACF1
##   &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Drift  Test  0.877 0.940 0.877  7.62  7.62  6.55  4.94 0.666
## 2 Mean   Test  2.47  2.49  2.47  21.6  21.6  18.4  13.1  0.663
## 3 Naïve  Test  0.862 0.924 0.862  7.49  7.49  6.44  4.85 0.663
```

---
# Assessing Coverage

Four scores:
1. Quantile  
2. Winkler Scores  
3. Continuous Ranked Probability Scores  
4. Relative Skill Scores  

---
# TSCV

`stretch_tsibble`


```r
F.Ford.Training &lt;- F.Ford %&gt;% stretch_tsibble(.init=10, .step=1)
F.Ford.Training %&gt;% model(`RW` = RW(close ~ drift()), `Mean` = NAIVE(close)) %&gt;% forecast(h=1) %&gt;% accuracy(F.Ford)
```

```
## # A tibble: 2 x 10
##   .model .type       ME  RMSE   MAE     MPE  MAPE  MASE RMSSE      ACF1
##   &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;
## 1 Mean   Test  -0.00336 0.191 0.134 -0.0600  1.65  1.00  1.00  0.000318
## 2 RW     Test   0.0105  0.192 0.135  0.0967  1.66  1.01  1.01 -0.00429
```
---
# The Forecast Horizon

How bad and how fast?

---
# Chapter 6: Judgemental Forecasts

Are not really why we are here but are common nevertheless....

---
# The Methods

1. Delphi [An Expert Ensemble]
2. Analogies  
3. Scenarios  
4. New things  
5. Adjustment  


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
